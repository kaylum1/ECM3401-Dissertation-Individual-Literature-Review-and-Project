"""
Tests for Passive_Vulnerability_Cross_Reference_Scanner.py
==========================================================

Run them from the project root with:

    python -m unittest Security_scans.Security_scans_tests.Passive_Vulnerability_Cross_Reference_Scanner_test -v
"""
import requests
from types import SimpleNamespace
from unittest import TestCase, mock

# Local import – mirrors the package layout in production
from Security_scans import Passive_Vulnerability_Cross_Reference_Scanner as scanner


class VulnCrossRefScannerTests(TestCase):
    """Smoke-, edge- and worst-case tests for the cross-reference scanner."""

    # ------------------------------------------------------------------ #
    # get_headers  (HEAD wrapper)
    # ------------------------------------------------------------------ #
    @mock.patch("Security_scans.Passive_Vulnerability_Cross_Reference_Scanner.requests.head")
    def test_get_headers_happy_path(self, fake_head):
        fake_head.return_value = SimpleNamespace(headers={"Server": "nginx/1.18"}, status_code=200)
        hdrs = scanner.get_headers("https://ok.example")
        self.assertEqual(hdrs, {"Server": "nginx/1.18"})
        fake_head.assert_called_once_with("https://ok.example", allow_redirects=True, timeout=10)

    @mock.patch(
        "Security_scans.Passive_Vulnerability_Cross_Reference_Scanner.requests.head",
        side_effect=requests.RequestException("boom")
    )
    def test_get_headers_graceful_failure(self, _fake_head):
        hdrs = scanner.get_headers("https://fail.example")
        self.assertEqual(hdrs, {})

    # ------------------------------------------------------------------ #
    # get_content – GET wrapper
    # ------------------------------------------------------------------ #
    @mock.patch("Security_scans.Passive_Vulnerability_Cross_Reference_Scanner.requests.get")
    def test_get_content_happy_path(self, fake_get):
        fake_get.return_value = SimpleNamespace(
            text="<html/>",
            status_code=200,
            raise_for_status=lambda: None
        )
        html = scanner.get_content("https://ok.example")
        self.assertEqual(html, "<html/>")
        fake_get.assert_called_once_with("https://ok.example", timeout=10)

    @mock.patch(
        "Security_scans.Passive_Vulnerability_Cross_Reference_Scanner.requests.get",
        side_effect=requests.RequestException("boom")
    )
    def test_get_content_graceful_failure(self, _fake_get):
        html = scanner.get_content("https://fail.example")
        self.assertIsNone(html)

    # ------------------------------------------------------------------ #
    # detect_technologies – header + script sniffing
    # ------------------------------------------------------------------ #
    def test_detect_technologies_from_headers_and_scripts(self):
        headers = {
            "Server": "Apache/2.4.46 (Unix)",
            "X-Powered-By": "PHP/7.4.3"
        }
        html = """
            <script src="https://cdn.example.com/jquery-3.5.1.min.js"></script>
            <script src="bootstrap-4.6.0.min.js"></script>
        """
        tech = scanner.detect_technologies("https://site.example", headers, html)
        # Should detect Server, X-Powered-By, jQuery, and Bootstrap
        self.assertIn("Server", tech)
        self.assertEqual(tech["Server"], "Apache/2.4.46 (Unix)")
        self.assertIn("X-Powered-By", tech)
        self.assertEqual(tech["X-Powered-By"], "PHP/7.4.3")
        self.assertIn("jQuery", tech)
        self.assertEqual(tech["jQuery"], "3.5.1")
        self.assertIn("Bootstrap", tech)
        self.assertEqual(tech["Bootstrap"], "4.6.0")

    # ------------------------------------------------------------------ #
    # check_vulnerabilities – CVE lookup & score math
    # ------------------------------------------------------------------ #
    @mock.patch("Security_scans.Passive_Vulnerability_Cross_Reference_Scanner.requests.get")
    def test_check_vulnerabilities_score_and_notes(self, fake_get):
        # React returns two CVEs; fontawesome returns none.
        cve_items = [
            {
                "impact": {"baseMetricV3": {"cvssV3": {"baseSeverity": "HIGH"}}},
                "cve": {"CVE_data_meta": {"ID": "CVE-123"}},
            },
            {
                "impact": {"baseMetricV3": {"cvssV3": {"baseSeverity": "LOW"}}},
                "cve": {"CVE_data_meta": {"ID": "CVE-456"}},
            },
        ]
        payload_react = {"result": {"CVE_Items": cve_items}}
        payload_empty = {"result": {"CVE_Items": []}}

        def side_effect(url, timeout=10):
            if "react%2018.2.0" in url:
                return SimpleNamespace(json=lambda: payload_react)
            return SimpleNamespace(json=lambda: payload_empty)

        fake_get.side_effect = side_effect

        tech_map = {"react": "18.2.0", "fontawesome": "6.5.0"}
        score, notes = scanner.check_vulnerabilities(tech_map)

        # Only react incurred two CVEs: 3 + 1 = 4 penalty → 10 − 4 = 6
        expected = max(1, 10 - 4)
        self.assertEqual(score, expected)
        # Notes should mention CVE-123 and CVE-456 under "react"
        self.assertTrue(any("cve-123" in n.lower() for n in notes))
        self.assertTrue(any("cve-456" in n.lower() for n in notes))
        # Final summary line present
        self.assertTrue(notes[-1].lower().startswith(("no cves", "moderate risk", "high risk")))

    # ------------------------------------------------------------------ #
    # get_base_url – normalization
    # ------------------------------------------------------------------ #
    def test_get_base_url(self):
        self.assertEqual(scanner.get_base_url("example.com"), "https://example.com")
        self.assertEqual(scanner.get_base_url("http://foo.bar/path"), "http://foo.bar")

    # ------------------------------------------------------------------ #
    # analyze_vulnerabilities – end-to-end wrapper
    # ------------------------------------------------------------------ #
    @mock.patch("Security_scans.Passive_Vulnerability_Cross_Reference_Scanner.get_headers")
    @mock.patch("Security_scans.Passive_Vulnerability_Cross_Reference_Scanner.get_content")
    @mock.patch("Security_scans.Passive_Vulnerability_Cross_Reference_Scanner.detect_technologies")
    @mock.patch("Security_scans.Passive_Vulnerability_Cross_Reference_Scanner.check_vulnerabilities")
    def test_analyze_vulnerabilities_success(self, fake_xref, fake_detect, fake_content, fake_headers):
        fake_headers.return_value = {"Server": "nginx"}
        fake_content.return_value = "<html/>"
        fake_detect.return_value = {"react": "18.2.0"}
        fake_xref.return_value = (8, ["note1", "note2"])

        score, notes_str = scanner.analyze_vulnerabilities("https://demo.example")
        self.assertEqual(score, 8)
        # Notes are returned as a semicolon-separated string
        self.assertEqual(notes_str, "note1; note2")

        fake_headers.assert_called_once_with("https://demo.example")
        fake_content.assert_called_once_with("https://demo.example")
        fake_detect.assert_called_once_with("https://demo.example", {"Server": "nginx"}, "<html/>")
        fake_xref.assert_called_once_with({"react": "18.2.0"})

    @mock.patch("Security_scans.Passive_Vulnerability_Cross_Reference_Scanner.get_headers", return_value={})
    @mock.patch("Security_scans.Passive_Vulnerability_Cross_Reference_Scanner.get_content", return_value=None)
    def test_analyze_vulnerabilities_failure(self, fake_content, fake_headers):
        score, notes_str = scanner.analyze_vulnerabilities("https://nope.local")
        self.assertEqual(score, 1)
        self.assertEqual(notes_str, "Error fetching headers or content.")
